{"pages":[{"title":"å…³äº Ray Eldath","text":"Ray Eldathï¼Œä½äºé“¶æ²³ç³»çŒæˆ·åº§æ‚¬è‡‚æœ«ç«¯æŸæ˜Ÿçƒçš„ä¸€åªé»‘çŒ«çŒ«ï¼š èªæ…§è¿‡çŒ«ã€‚ä¼šğŸ¥ï¼Œå®¶é‡Œæœ‰ä¸€å¥—å·¨æ‰°æ°‘çš„ç¾æ´¾æ–¯ï¼Œç»å¸¸è¢«æŠ•è¯‰ï¼Œæ¢¦æƒ³æ˜¯æ”’é’±ä¹°åˆ°PAISTE 900 Rideå’ŒByzance HiHatã€‚æ­£åœ¨å­¦ğŸ¸ï¼Œç»ƒä¹ çš„æ—¶å€™ç»å¸¸æ€€ç–‘è‡ªå·±çš„æ‰‹æŒ‡æ•°é‡ã€‚ å–œæ¬¢å¤–å›½æ–‡å­¦å’Œç§‘å¹»ã€‚åˆä¸€å¼€å§‹çœ‹çš„SFWï¼Œå¾ˆå¯æƒœçš„æ˜¯çœ‹äº†è¿™ä¹ˆå¤šå¹´åŸºæœ¬éƒ½æ˜¯å›¾ä¹¦é¦†å€Ÿçš„â€¦ æ‰‹å¤´æœ‰çš„æ‚å¿—æ²¡æœ‰å¤šå°‘ï¼Œå¾ˆå¸Œæœ›2023å¹´èƒ½å»æˆéƒ½å‚åŠ Worldconâ€¦â€¦ å¯¹é»„é‡‘æ—¶ä»£ç§‘å¹»å’Œå¤§åˆ˜å¼ç§‘å¹»ä¸å¤§æ„Ÿå†’ï¼Œè¾ƒå–œæ¬¢æ–°æµªæ½®ç§‘å¹»ï¼›æœ€å–œæ¬¢çš„ç§‘å¹»ä½œå®¶æ˜¯æµ·å› è±èŒµï¼›å›½å†…æœ‰ä¸€äº›æµªæ¼«ä¸»ä¹‰ä¸­çŸ­ç¯‡ç§‘å¹»ä¹Ÿå¾ˆå–œæ¬¢ï¼Œæ¯”å¦‚é˜¿ç¼ºçš„å¾ˆå¤šä½œå“ï¼ˆå¦‚ã€Šå½¼å²¸èŠ±ã€‹ï¼‰ï¼Œã€Šé—ªè€€ã€‹è¿˜æœ‰ã€Šä¸ƒä¸ªå»ã€‹ç­‰ã€‚é™¤å¼€ç§‘å¹»æœ€å–œæ¬¢çš„ä½œå®¶æ˜¯é˜¿å°”è´Â·åŠ ç¼ªï¼Œè¿˜æ¯”è¾ƒå–œæ¬¢é»‘å¡ã€æµ·æ˜å¨å’Œæ¯›å§†ã€‚æ¬¢è¿å®‰åˆ©å„ç§ä½œå“qwq ç¨å¾®çœ‹ä¸€äº›åŠ¨æ¼«ï¼Œç°åœ¨åŸºæœ¬é€€å®…ï¼Œå–œæ¬¢ã€ŠEVAã€‹å’Œã€Šå¤ç›®å‹äººå¸ã€‹ã€‚æœ‰ä¸€åªæœ‹å‹é€çš„å–µå’ªè€å¸ˆï¼Œå¾ˆå¼€å¿ƒã€‚ æŠ€æœ¯èœï¼Œåœ¨è®¤è¯†çš„æŠ€æœ¯åœˆé‡Œå‡ ä¹å«åº•â€¦ ç»å¸¸è‡ªé—­ã€‚ç›®å‰å¾ˆè¿·èŒ«ï¼Œæ­£åœ¨çå­¦ä¸œè¥¿ï¼ŒæœŸæœ›æœªæ¥èƒ½åšå¤§æ•°æ®æ–¹å‘çš„å·¥ä½œã€‚GitHubåœ°å€è§å·¦ä¾§ï¼Œæ¬¢è¿äº’foã€‚ å–œæ¬¢æ—…æ¸¸ï¼Œå–œæ¬¢å¤§åŸå¸‚çš„æ°”æ¯ã€‚å¤§å­¦å››å¹´ç†æƒ³æ˜¯æ¢ç”µè„‘+å¯Œå£«XT30+åœ¨æŠ¤ç…§è¿‡æœŸå‰å»ä¸€è¶Ÿæ—¥æœ¬ã€‚æœŸæœ›èƒ½å®ç°â€¦â€¦.. å¤§å“­å“­ ä»å°åˆ°å¤§æˆç»©éƒ½å·®ï¼Œä¸å–œæ¬¢ä¹Ÿä¸æ“…é•¿æ•°å­¦ç‰©ç†ï¼Œä¸€ç”Ÿä¹‹æ•Œï¼›åŠªåŠ›å¤ªæ™šï¼Œåƒäº†å¾ˆå¤šäºã€‚ å¦‚æœæœ‰æƒ³å’Œæœ¬å¸…çŒ«äº¤æ¢å‹é“¾çš„æ¬¢è¿ç•™è¨€ã€‚çˆ±ä½ ä»¬ã€‚","link":"/about/index.html"},{"title":"ç•™è¨€æ¿","text":"ç•™ä¸‹è¶³è¿¹å§ï¼","link":"/messages/index.html"}],"posts":[{"title":"é˜¿å°”è´Â·åŠ ç¼ªå…¶äºº","text":"ä»–åœ¨æœ¬ä¸–çºªé¡¶ä½äº†å†å²æ½®æµï¼Œç‹¬è‡ªç»§æ‰¿ç€æºè¿œæµé•¿çš„è­¦ä¸–æ–‡å­¦ã€‚ä»–æ€€ç€é¡½å¼ºã€ä¸¥æ ¼ã€çº¯æ´ã€è‚ƒç©†ã€çƒ­æƒ…çš„äººé“ä¸»ä¹‰ï¼Œå‘å½“ä»Šæ—¶ä»£çš„ç§ç§ç²—ä¿—ä¸‘é™‹å‘èµ·èƒœè´Ÿæœªåœçš„å®£æˆ˜ã€‚ä½†æ˜¯åè¿‡æ¥ï¼Œä»–ä»¥è‡ªå·±å§‹ç»ˆå¦‚ä¸€çš„æ‹’ç»ï¼Œåœ¨æˆ‘ä»¬çš„æ—¶ä»£ï¼Œå†æ¬¡é‡ç”³åå¯¹æ‘’å¼ƒé“å¾·çš„é©¬åŸºé›…ç»´åˆ©ä¸»ä¹‰ï¼Œåå¯¹è¶‹ç‚é™„åŠ¿çš„ç°å®ä¸»ä¹‰ï¼Œè¯å®é“å¾·çš„å­˜åœ¨ã€‚ é˜¿å°”è´Â·åŠ ç¼ªæ˜¯èœšå£°ä¸­å¤–çš„å‰§ä½œå®¶ã€æ–‡å­¦å®¶å’Œå“²å­¦å®¶ã€‚å› å…¶ä»¥è’è°¬ã€å½»æ‚Ÿå’ŒåæŠ—ä¸ºæ ¸å¿ƒçš„â€œè’è°¬ä¸»ä¹‰â€ â€œçƒ­æƒ…è€Œå†·é™åœ°é˜æ˜äº†å½“ä»£å‘äººç±»è‰¯çŸ¥æå‡ºçš„ç§ç§é—®é¢˜â€ è€Œè·1957å¹´è¯ºè´å°”æ–‡å­¦å¥–ï¼Œè·å¥–æ—¶å¹´ä»…å››åå››å²ã€‚1913å¹´11æœˆ7æ—¥ï¼ŒåŠ ç¼ªå‡ºç”Ÿåœ¨é˜¿å°”åŠåˆ©äºšå°é•‡è’™å¤šç»´çš„ä¸€ä¸ªå·¥äººå®¶åº­ï¼Œå¦‚ä»–è‡ªå·±æ‰€è¿°ï¼Œâ€œèµ¤è´«â€ã€â€œä»æ¥æ˜¯ä¸€ä¸ªæ— äº§è€…â€ï¼Œè´«å›°æ„æˆäº†åŠ ç¼ªæ—©å¹´ç”Ÿæ´»çš„åŸºè°ƒï¼›ä¸ä»…èµ¤è´«ï¼Œå¤±å»çˆ¶äº²æ›´ä½¿å¾—åŠ ç¼ªâ€œå­¤ç«‹æ— æ´â€ï¼Œâ€œåªèƒ½é ä¸€å·±ä¹‹åŠ›é¢†æ‚Ÿé“ç†ï¼Œå…»æˆç‹¬ç«‹çš„äººæ ¼ï¼Œæˆé•¿ä¸ºä¸€ä¸ªç”·å­æ±‰â€ã€‚åœ¨è¿™æ ·çš„ç¯å¢ƒä¸‹ï¼Œåœ¨å‘ä»–æä¾›æ— å°½è´¢å¯Œï¼Œæ²™æ»©ã€é˜³å…‰å’Œå¤§æµ·çš„è´å°”åº“è´«æ°‘åŒºï¼ŒåŠ ç¼ªä¸ä¼™ä¼´ä»¬å¿«ä¹åœ°ç©è€ã€æˆé•¿ã€åœ¨æ¸©çƒ­çš„æµ·æ°´ä¸­æ¸¸æ³³ï¼Œåœ¨æ—¥å…‰ä¹‹ä¸‹å¬‰æˆã€‚åŠ ç¼ªå¯¹é‚£æ ·çš„æ—¶å…‰æ»¡æ€€æ„Ÿæ¿€å’Œæ€€å¿µï¼Œè¿™åœ¨ã€Šç¬¬ä¸€äººã€‹ä¸­ä½“ç°åœ°æ·‹æ¼“å°½è‡´ï¼šæ˜¾ç„¶ï¼Œæ—©å¹´çš„å›°è‹¦ç”Ÿæ´»å¹¶æœªé˜»æŒ¡è¿™ä½ä½œå®¶å¯¹ä¸–ç•Œã€äººç±»ã€å¤§åœ°å’Œç—›è‹¦çš„å…³åˆ‡ï¼Œä»ã€Šé¼ ç–«ã€‹ä¸­é‡Œå„åŒ»ç”Ÿå’Œå¡”é²åˆæ¬¡è§é¢æ—¶çš„é•¿è°ˆï¼Œåˆ°ä½œå“ç»“å°¾å¡”é²é‚£æ®µå‘äººæ·±çœçš„è‡ªç™½ï¼Œæ— ä¸è¡¨æ˜æ­£æ˜¯è¿™ç§å›°è‹¦ï¼Œæ•™ä¼šè¿™ä½æœªæ¥çš„è¯ºå¥–å¾—ä¸»è¦å–„è‰¯ï¼Œè¦å…³æ€€äººï¼Œè¦åŒæƒ…äººï¼Œè¦æœ‰æ€œæ‚¯ä¹‹å¿ƒã€‚1924å¹´6æœˆï¼ŒåŠ ç¼ªä»¥ä¸€å¦‚æ—¢å¾€çš„ä¼˜å¼‚æˆç»©æˆä¸ºå®¶æ—ä¸­ç¬¬ä¸€ä½æœ‰æœºä¼šå°±è¯»ä¸­å­¦çš„äººï¼›åœ¨ä»–çš„å­¦ç”Ÿç”Ÿæ¶¯ä¸­ï¼Œè¿™ä½ä½œå®¶ä¸ä»–çš„å°å­¦æ•™å¸ˆè·¯æ˜“Â·çƒ­å°”æ›¼ä»æ™®é€šçš„å¸ˆç”Ÿå…³ç³»åˆ°å¿˜å¹´äº¤ï¼ŒåŠ ç¼ªä»æœªå¿˜è®°è¿™ä½æŒ‡å¼•äº†ä»–æ–¹å‘ã€å¸¦ç»™äº†ä»–å…‰æ˜çš„å¾·é«˜æœ›é‡çš„æ³•è¯­ç‰¹çº§æ•™å¸ˆï¼Œä»–å…±æœ‰å››éƒ¨ä½œå“ã€æ–‡ç« çŒ®ç»™è¿™ä½æ•™å¸ˆï¼Œå…¶ä¸­åŒ…æ‹¬è¯ºè´å°”æ–‡å­¦å¥–ç­”è°¢è¯ã€‚1937å¹´5æœˆ10æ—¥ï¼Œã€Šåä¸æ­£ã€‹å‡ºç‰ˆï¼Œæ ‡å¿—ç€åŠ ç¼ªæ­£å¼è¿›å…¥æ–‡å­¦ç•Œã€‚åœ¨åŠ ç¼ªä¸é•¿çš„æ–‡å­¦ç”Ÿæ¶¯ä¸­ï¼Œä»–å‘è¡¨äº†å¤šéƒ¨æ–‡å­¦ã€å“²å­¦è‘—ä½œå’Œå‰§æœ¬ï¼Œè¿˜åœ¨å„å¤§è¿›æ­¥æŠ¥åˆŠä¸Šå£°æ´æŠµæŠ—ç»„ç»‡ï¼Œå¹¶èº«ä½“åŠ›è¡Œåœ°æ‰¿æ‹…æƒ…æŠ¥æœé›†å’Œå‡ºç‰ˆä»»åŠ¡ï¼ŒåŒçš®äºšã€é›·è¯ºç­‰æŠµæŠ—è¿åŠ¨æˆ˜å£«è”ç³»å¯†åˆ‡ã€‚1943å¹´6æœˆï¼ŒåŠ ç¼ªçš„æˆå‰§ã€Šè‹è‡ã€‹é¦–æ¼”ï¼Œè·å¾—æå¤§æˆåŠŸï¼›åœ¨é¦–æ¼”å¼ä¸Šï¼ŒåŠ ç¼ªè®¤è¯†äº†è‘—åå­˜åœ¨ä¸»ä¹‰å“²å­¦å®¶è¨ç‰¹ï¼Œå¹¶ä¸ä¹‹ç»“ä¸‹å‹è°Šï¼Œä»–ä»¬ç»å¸¸åœ¨å’–å•¡é¦†è®¨è®ºæ”¿æ²»ã€å“²å­¦å’Œæ–‡å­¦ï¼Œè¨ç‰¹ä¹Ÿå¤šæ¬¡è¡¨è¾¾å¯¹è¿™ä½â€œå¹´è½»å°ä¼™å­â€çš„å–œçˆ±â€”â€”ç›´åˆ°1951å¹´ã€‚1951å¹´10æœˆ18æ—¥ï¼Œã€ŠåæŠ—è€…ã€‹å‡ºç‰ˆï¼ŒåŠ ç¼ªåœ¨è¯¥ä¹¦ä¸­æå‡ºçš„æ–°äººé“ä¸»ä¹‰å¼•å‘ä»–å’Œè¨ç‰¹é•¿è¾¾ä¸€å¹´çš„æ¿€çƒˆè®ºæˆ˜ï¼Œå¹¶ä»¥ä¸¤äººçš„å½»åº•å†³è£‚ç»“æŸã€‚1959å¹´11æœˆï¼Œä½œå“ã€Šç¬¬ä¸€äººã€‹ç¬¬ä¸€éƒ¨åˆ†åˆç¨¿å®Œæˆï¼Œä»–è®¡åˆ’åœ¨1960å¹´7æœˆå®Œæˆåˆç¨¿ï¼Œå¹¶äº1961å¹´å®Œæˆç¬¬äºŒç¨¿ï¼Œæˆ–è®¸å³æ˜¯å®šç¨¿ã€‚ ä½†è¿™ä¸€åˆ‡åœ¨æ¬¡å¹´å¹´åˆæˆ›ç„¶è€Œæ­¢â€”â€”1960å¹´1æœˆ4æ—¥ï¼Œé˜¿å°”è´Â·åŠ ç¼ªä¹˜æ±½è½¦å›å·´é»æ—¶è½¦ç¥¸èº«äº¡ï¼Œäº«å¹´å››åå…­å²ã€‚ä»–çš„ç¦»ä¸–ç»™æ³•å›½çŸ¥è¯†ç•Œå¸¦æ¥æå¤§éœ‡åŠ¨ï¼Œä¸€æ—¶é—´æ‚¼å¿µæ–‡ç« é“ºå¤©ç›–åœ°ã€‚åœ¨è¿™äº›æ‚¼å¿µæ–‡å­—ä¸­ï¼Œå°¤ä»¥åŠ ç¼ªçš„å‰è®ºæ•Œâ€”â€”æˆ–è®¸è¿˜èƒ½ç§°ä¸ºâ€œå‰â€â€œå‰æŒšå‹â€â€”â€”è¨ç‰¹çš„æ‚¼è¯æœ€ä¸ºæ„Ÿäººï¼Œä¹Ÿå³æ˜¯æœ¬æ–‡å¼€å¤´å¼•ç”¨çš„é‚£æ®µè¯ã€‚éšç€åŠ ç¼ªçš„ç¦»å»ï¼Œä»–æ‰€å…³æ³¨çš„æ”¿æ²»é—®é¢˜ä¹Ÿèµ°å‘å½»åº•è§£å†³ï¼Œå…¶å“²å­¦è®¨è®ºäº¦è¢«äººä»¬é—å¿˜ï¼ŒåŠ ç¼ªçš„æ€æƒ³å’Œå£°éŸ³ï¼Œä¾¿é€æ¸æˆä¸ºå·²ç„¶é€å»çš„å†å²ä¸­ä¸€ç§é¥è¿œè€Œæ¨¡ç³Šçš„å›å“ã€‚ è¿›å…¥äºŒåä¸€ä¸–çºªï¼Œæ–°çš„é—®é¢˜å’ŒæŒ‘æˆ˜æ¥è¸µè€Œè‡³ã€‚ææ€–ä¸»ä¹‰æŠ¬å¤´ã€éš¾æ°‘é—®é¢˜ã€æ°”å€™å˜æš–ï¼Œç°åœ¨è¿˜æœ‰å…¨çƒæ€§ç—…æ¯’çš„ç©ºå‰å¤§æµè¡Œå’Œæ ¹æ·±è’‚å›ºçš„ç§æ—æ­§è§†ï¼šç§ç§å±æœºä½¿è¿·èŒ«å›°æƒ‘çš„äººä»¬åˆå°†ç›®å…‰é‡æ–°èšç„¦åˆ°è¿™ä½è‹±å¹´æ—©é€çš„å“²å­¦å®¶ä¸Šæ¥ã€‚åŠä¸ªä¸–çºªè¿‡å»ï¼Œå¦‚ä»ŠåŠ ç¼ªæœæ€æš®æƒ³çš„é˜¿å°”åŠåˆ©äºšå·²ç»ç‹¬ç«‹ï¼ŒäºŒåä¸–çºªæ¬§æ´²çŸ¥è¯†åˆ†å­çš„å·¦å€¾ç‹‚æ½®ä¹Ÿæ—©å·²è¿‡å»ï¼Œé‚£äº›å†·é™ä¸‹æ¥ã€åˆä¸€æ¬¡è®¤è¯†åˆ°è¿™ä½æ–‡ç¬”å‡ç‚¼çš„ä½œå®¶çš„æ–‡å­—ä¸­è•´å«æœ‰æ·±åˆ»ã€å¯Œæœ‰é“å¾·æ„ä¹‰å’Œä¸€ç§ä¼Ÿå¤§çš„äººé“ä¸»ä¹‰çš„å“²ç†çš„äººä»¬ï¼Œå¤§æ¦‚ä¸ä¼šå¦è®¤é˜¿å°”è´Â·åŠ ç¼ªåŠä¸ªä¸–çºªå‰é¢†æ‚Ÿåˆ°çš„é“ç†ï¼Œä»é—ªè€€ç€æ²‰é‡ä½†è½»ç›ˆã€ä¼Ÿå¤§ä½†å¹³å‡¡çš„äººé“ä¸»ä¹‰å…‰è¾‰ï¼š åœ¨è¿™å„¿æˆ‘é¢†æ‚Ÿäº†äººä»¬æ‰€è¯´çš„å…‰è£ï¼šå°±æ˜¯æ— æ‹˜æ— æŸåœ°çˆ±çš„æƒåŠ›ã€‚ â€”â€”é˜¿å°”è´Â·åŠ ç¼ª çºªå¿µç¢‘æ–‡é˜¿å°”åŠåˆ©äºš â€” å®Œã€‚â€” å‚è€ƒï¼š ã€ŠåŠ ç¼ªå…¨é›†ã€‹é˜¿å°”è´Â·åŠ ç¼ª ã€ŠåŠ ç¼ªç”Ÿå¹³ä¸åˆ›ä½œå¹´è¡¨ã€‹æç‰æ°‘ ã€Šè®ºåŠ ç¼ªçš„æ€æƒ³ä¸åˆ›ä½œã€‹æŸ³é¸£ä¹ ã€ŠåŠ ç¼ªçš„è‡ªæˆ‘è§£ç ã€‹æç‰æ°‘ ä»¥å‰å†™çš„è ¢ä¸œè¥¿â€¦ æ‹¿æ¥å‡‘ä¸ªæ•°å¥½äº†qvq","link":"/literature/albert-camus/"},{"title":"First Step Towards FPGA (1): SystemVerilog Quick Take &amp; Pros and Cons","text":"Every time programmable hardware programming is mentioned, Verilog or SystemVerilog comes to our mind â€” such fact, IMHO, is ironically contrasts with another interesting, if not consensus, but at least first impression of those hardware newbies just like me, that the fundamental software and development toolkit in hardware programming field is far from diverse, mature and easy-to-use. Comparing to software engineering, there are not too much languages, tools or methodology to let you pick and choose, even among the limited available choices, most of them are either lack some important features, or just too expensive to investigate. Undoubtedly my first step towards FPGA, looking around and pick a combination of language, simulator and testing method, is a brief journey, but it also involved too many investigation as well as unexpected disappointment, which makes this journey more difficult, and more tiring. This article is intended to outline some of my conclusion, which is what Iâ€™m using now, and what I have used but quited. For me, there is a long-lasting haunting thought â€” writing a CPU, and that is the beginning of the story. About half a month ago I set sailed, and till now I have finished a testing library for Verilator, and a very simple MIPSs CPU that have nothing to do with pipeline, trap, and whatnot. So conclusion comes first: Iâ€™ve done most of these in combination of SystemVerilog (language) + Verilator (simulator) + CLion (IDE) + althas (testing) + Xilinx Vivado (synthesis). I will explain the reason just below. Iâ€™ll not gonna say this is the best workflow of hardware programming, specifically FPGA programming, it still have many incompetence in terms of my requirements which Iâ€™ll talk about them later as well, but I do hope this article could help you find a workflow that just suits yourself. This article will only discuss the very first part of my workflow, namely the SystemVerilog part. Remaining techniques will be discussed in the follow-on articles of this series, so stay tuned! Verilog / SystemVerilog ?JUST DONâ€™T ask why VHDL is not mentioned. I wonâ€™t discuss VHDL here, for one thing I know nothing about this language, and for another I think itâ€™s somewhat considered obsolete or just not recommended in many existing articles like this one. Whatâ€™s different?SystemVerilog has been described as a superset of Verilog, which is another predominant language in hardware programming field, and it certainly is. SystemVerilog have an impressive outstanding compatibility with Verilog, most synthesis environment, at least Xilinx Vivado, allows you to instantiate Verilog module in SystemVerilog module and vice versa. Many Verilog definition could be directly translated into SystemVerilog, without or with only little altered. Here is a piece of code taken from my CPU project astrio (currently itâ€™s still in private, Iâ€™ll publish it once I finished pipelining, trap, AXI bus and implementation on Zynq SoC, all sort of things), it can help you â€” I assume you already knew Verilog, and understand what these assign, always means â€” glimpse at the vanilla-SystemVerilog, and understand whatâ€™s new there: >folded pc.svsee code on GitHub1234567891011121314151617181920212223242526272829303132333435363738import Parameters::*;import PCType::pc_cmd_t;import Types::addr_t;module PC( input PCType::pc_cmd_t cmd, input addr_t load_pc, input bit rst, input bit clk, output addr_t pc, output addr_t inc_pc); initial pc = InstStartFrom; addr_t next_pc; assign inc_pc = pc+4; always_comb begin unique case (cmd) PCType::NONE: next_pc = pc; PCType::INC: next_pc = inc_pc; PCType::INC_OFFSET: next_pc = inc_pc+load_pc; PCType::LOAD: next_pc = load_pc; default: next_pc = pc; endcase if (rst == 1) next_pc = InstStartFrom; end always_ff @(posedge clk) pc &lt;= next_pc;endmodule : PC Itâ€™s not difficult to find out that there are many differences comparing to Verilog. Iâ€™ll highlight those are most important or influential in terms of the actual programming work: typedef in SystemVerilogYou may notice that there are some addr_t stuff in the code, and even if you are just a newcomer of C, you may still notice that here we adhere to the general naming convention of a typedef, namely suffixed whatever a typedef with _t, which I think is just inherited from Câ€™s naming conventions. So as you may assumed, SystemVerilog do have typedef. Letâ€™s look at the definition of addr_t: types.svsee code on GitHub12345678910package Types; typedef logic unsigned [31:0] addr_t; typedef logic signed [31:0] op_t; typedef reg signed [31:0] op_reg_t; typedef logic unsigned [4:0] reg_id_t; typedef logic unsigned [31:0] inst_t; typedef reg unsigned [31:0] inst_reg_t;endpackage : Types Okay, now itâ€™s pretty clear. Generally typedef in SystemVerilog is no different from its counterpart in C/C++. Intuition always right, just use typedef (type) (name) to define your own data type in SystemVerilog to make your code more concise and configurable. BTW, typedef is a great replacement for parameter in many cases, use it wisely, and your code will definitely looks better. But, wait, what the hell is the package? package &amp; import: Package system and separate compilationExtract the common definition of your code, wrapped them in a package or whatever is always a good idea. It improves the readability of your code, alleviate namespace conflicts, and enables the separate compilation, i.e. when the code are recompiled, only the modified part is needed to be recompiled while the common and relatively less frequently modified part can be excluded, so less files will be recompiled, therefore speed up the recompilation. SystemVerilog supports such encapsulation by providing keyword package and import: the former is for encapsulate, the latter is for import it. One thing should be noticed: if you read my codebase that linked hereinbefore, you may find that only typedef, functions and some parameters are encapsulated in package, this is because typically they are the common part of your code. I wonâ€™t encapsulate my module in package, seems to me it just donâ€™t deserve. enum &amp; enhanced case clause: enumeration works like a charmIn the pc.sv code above, there is a input cmd typed PCType::pc_cmd_t. You may guess that this is a typedef defined in package PCType, but what the actual type is? Continual reading, the input cmd is passed into a unique case clause, perhaps itâ€™s something akin to enumeration? And unique means that there are no overlapping between the matching conditions, so only one block will be triggered in any cases? You are right! Hereâ€™s the definition of pc_cmd_t: pc_type.svsee code on GitHub12345package PCType; typedef enum bit [1:0]{ NONE, INC, INC_OFFSET, LOAD } pc_cmd_t /* verilator public */;endpackage : PCType Here we define a enum that occupies a 2 bit wide bit, then aliased it as a pc_cmd_t, where we adhere to the appreciated naming conventions. The whole definition is encapsulated in a package named PCType as I discussed before. Still there are something weird â€” what is the bit? And why there is a comment /* verilator public */? I am going to talk about the bit thing right now, but for the Verilator thing, till we know what Verilator is and what can it do can we grasp at the idea, so the answer is in the follow-on articles of this series. logic &amp; bit: abundant but systematic built-in datatypeIn addition to the native datatypes directly inherited from Verilog, lots of new datatypes are described and added. Presumably the most crucial subset of these novel datatypes (I think many of them is just excessive abstraction and design and actually not so required but make the language considerably more complex. Iâ€™ll back to this point later) is logic and bit. Technically you can regard logic as wire plus reg. Datatype logic wipe out the delimited wire and reg, for synthesizer will deduce the underlying hardware (a wire or a register) automatically, using the context. But if you are declaring a tristate gate like inout, you have to use wire but not logic. Why is that? The reason is logic-typed variables can only have one driver. No surprise here, logic still have four state: 0 (low), 1 (high), X (unknown) and Z (tristate gate high-impedance), but in many cases we can firmly believe that only two state, 0 and 1, will be involved. And thatâ€™s what bit used for. Itâ€™s a apt datatype for defining enumeration. Actually there are plentiful datatypes newly added into SystemVerilog, and most of them are not mentioned here due to some reasons, and Iâ€™ll come to this later. always_XXX: enhanced always clause enable fine-grained elaboration hintMaybe the most complex, sophisticated and perplexing part of Verilog/SystemVerilog is the always clause. Without intensive study, profound understanding and very careful development, unintended latch or flipflop will be deduced with no warnings, which surely is a bad thing. SystemVerilog partially solve this problem by giving you fine-grained elaboration hint. There are three types of new enhanced always clause: always_comb: Next time you write down always @(*), try always_comb! This type of always clause family will automatically listen to all left-side wires and registers in your begin â€¦ end block, thus sensitive signal list should not be specified. Simulator and synthesizer will ensure that only combinational logic is deduced, and if not, a warning (or error?) will be thrown. You should not use delayed assignment (&lt;=) in the context as well. always_ff @(...), always_latch @(...): Take their names literally, these two clause is for sequential logic. One will hints simulator and synthesizer to deduce flip-flop, the other will deduces latch. The sensitive signal list is required, and you should specify the sensitive signals in it, exp. always_ff @(posedge clk), just like in Verilog. Silver Bullet?But still, SystemVerilog is not the silver bullet, and here are some downsides. Relatively poor ecosystemBefore you switch to SystemVerilog (which I highly recommend, as many renowned hardware workshops and companies had done so), the very first as well as the most significant thing you should deliberately consider is ecosystem. That is to say, does the synthesizer, implementation program or IDE support SystemVerilog? And if not, apparently SystemVerilog can not be a practical option. The good news is that almost every conceivable mainstream FPGA manufacture provides development environment with bundled SystemVerilog support â€” but the bad news is SystemVerilog is only supported in their relatively newer version of software. Take Intel and Xilinx as example, only Quartus II 11.1 and above and Vivado v2017.3 and above support SystemVerilog. So if youâ€™re planning to program on old devices, such as a Xilinx Spartan-6, you are not able to use SystemVerilog since Vivado only supports 7 generation FPGA products (Zynq 7000 SoC, Artix-7, Kintex-7 and Virtex-7). Notice that some so-called individual manufacture, in particular Alchitry â€” the manufacture of the somewhat relatively reputable cheap, newcomer-friendly FPGA development board Mojo, do not provide SystemVerilog in their dedicated IDE as well. SystemVerilog is (overly?) complexAs I mentioned before, SystemVerilog is a complex HDL. But the problem is itâ€™s not just simply complex, itâ€™s somewhat overly and unnecessarily complex. Comparing with Verilog, actually many enhancements are reasonable, adequate and competent, but the other side is there are many features just trying to make coding in SystemVerilog as closer to coding in some high-level language, letâ€™s say C++ and Java, as possible, and this way is just not so great. Many language features and keywords, such as datatypes int, longint, real, crappy multi-thread support, keyword automatic for recursive functions, they are not used in my day-to-day programming, but makes SystemVerilog unreasonably complex â€” as a HDL, whose theoretical role is just describes wires between hardware structures. Iâ€™ll say that this attempt, trying to â€œdisguiseâ€ SystemVerilog as a high-level language will indeed improve the testing experience. (Personally speaking the TESTBENCH-based and $display-based testing methodology of Verilog is incredibly inefficient and grueling, I suppose the SystemVerilog way of doing things will be a lot easier) But, I still hold the belief that HDL should be a HDL solely, and high-level language should be a high-level language solely. Itâ€™s just redundant, and usually a bad idea to let one side covers the other side, or to â€œbeâ€ the other side. Given the consensus that hardware validation and testing, especially the generation of testcases should be performed in a high-level language, maybe use a high-level language to do such things will be a great idea â€” and Verilator is created for this. I will cover Verilator and related topics in the next article. After all, this is just a personal preference and personal perspective, and language is just a tool. If itâ€™s too complicated, just pick out the acceptable part: and this is exactly what Iâ€™m doing. Use what I called vanilla-SystemVerilog is just stick to the principle that SystemVerilog is nothing but a HDL language, you should only use the HDL part of it, take is as a â€œbetter Verilogâ€, use entirely a handful of features and enhancements including what I mentioned before. Limited featuresEven if your environment fully support SystemVerilog in elaboration, synthesis and implementation, your switch may still not very pleasant as you may expected. Specifically, my Vivado v2019.2 satisfactorily supports SystemVerilog in normal develop procedure, but you canâ€™t add your SystemVerilog modules to your Block Design directly. Overall this is not a big problem, in my case all I need is just to create a wrapper in Verilog then linked IPs to that wrapper, but your mileage may vary. It all depends.Eventually comes the golden rule of selecting things in the realm of techniques, technicians, languages and programmers â€” â€œIt all depends.â€ As I said, language is nothing but a tool, how to use it and to what extent will you use it in the daily basis, is just personal predilections. Tons of tutorials and blog posts will teach you how to use SystemVerilog as a high-level language and do validation things in such way elegantly â€” and I bet many people are good at it. But Iâ€™m just not on their side, nor am I appreciate their methodology. Hope this article will help you get the basic difference, pros and cons of SystemVerilog, comparing with Verilog, and then decide whether to put it in your own workflow. The next passage will cover another facet of my workflow â€” Verilator, it lets you simulate and validate your DUT in C++/System C, which is a lot better then do such things in HDL, personally speaking.","link":"/hardware/fpga-journey-1/"},{"title":"å’±çš„æ–°åšå®¢","text":"ä¸€ç›´æ‰“ç®—è‡ªå·±å†™åšå®¢çš„ä¸€å¥—å‰ç«¯å’Œåç«¯ï¼Œå‰ç«¯æœ¬æ¥å·²ç»å†™äº†æŒºå¤šçš„äº†ï¼Œç°åœ¨çœ‹æ¥æ˜¯è¦æç½®å¾ˆé•¿ä¸€æ®µæ—¶é—´äº†â€¦ æ„Ÿè§‰æŠ˜è…¾è¿™äº›æ¯•ç«Ÿæ²¡å•¥ç”¨ï¼Œè¿˜æ˜¯è¦èŠ±æ—¶é—´å†™æ–‡ç« æ‰è¡Œã€‚ã€‚ å¯æ–‡ç« ä¹Ÿå¤ªéš¾å†™å•¦QAQï¼Œæ¯æ¬¡éƒ½æ„Ÿè§‰å¼€å‘å†™äº†ä¸¤è¡Œå°±ä¸æƒ³åŠ¨äº†ï¼Œæ€»æ„Ÿè§‰æœ‰äº›ä¸œè¥¿ä¸èƒ½è¯´å¾—æœ‰äº›è§åœ°å°±ä¸å¦‚å¹²è„†ä¸åŠ¨ç¬”ä»¥é¿å…ã€ŒçŒæ°´ã€ä¹‹å«Œã€‚æ€»ä¹‹ä»¥å‰çš„æ–‡ç« å¤§æ¦‚æ˜¯ä¸ä¼šå‘ä¸Šæ¥äº†ï¼ˆå› ä¸ºå¤ªé»‘å†å²äº†ï¼Œå“­å“­ï¼‰è¿™ä¸ªåšå®¢å¤§æ¦‚ä¼šæ”¾äº›è¿‘æœŸè‡ªå·±å†™çš„ä¸œè¥¿ï¼Œç§‘å¹»è¯„è®ºå•Šï¼Œä»¥åŠç¨å¾®é•¿ä¸€äº›ã€å›¾æ–‡å¹¶èŒ‚çš„ã€ä¸é€‚åˆæ”¾åœ¨å’±Telegram Channelï¼ˆå·¦ä¾§æœ‰é“¾æ¥ï¼‰çš„ä¸€äº›ç©æ„ï¼Œå‘eå“¥å’Œå†°å†°ä¸¤ä½å¤§ä½¬çœ‹é½QAQ å°±æ˜¯è¿™æ ·ã€‚æ€»æ„Ÿè§‰ç°åœ¨è¿™ä¸ªæ–°ä¸»é¢˜æœ‰ç‚¹å¤ªå†·æ·¡äº†äº›ï¼Œä»¥åå†æ…¢æ…¢è°ƒå§â€¦â€¦","link":"/misc/hello-world/"}],"tags":[{"name":"é˜¿å°”è´Â·åŠ ç¼ª","slug":"é˜¿å°”è´Â·åŠ ç¼ª","link":"/tags/%E9%98%BF%E5%B0%94%E8%B4%9D%C2%B7%E5%8A%A0%E7%BC%AA/"},{"name":"æ–‡å­¦","slug":"æ–‡å­¦","link":"/tags/%E6%96%87%E5%AD%A6/"},{"name":"ç¡¬ä»¶ç¼–ç¨‹","slug":"ç¡¬ä»¶ç¼–ç¨‹","link":"/tags/%E7%A1%AC%E4%BB%B6%E7%BC%96%E7%A8%8B/"},{"name":"SystemVerilog","slug":"SystemVerilog","link":"/tags/SystemVerilog/"},{"name":"FPGA","slug":"FPGA","link":"/tags/FPGA/"}],"categories":[{"name":"literature","slug":"literature","link":"/categories/literature/"},{"name":"hardware","slug":"hardware","link":"/categories/hardware/"},{"name":"misc","slug":"misc","link":"/categories/misc/"}]}