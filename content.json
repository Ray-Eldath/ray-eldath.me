{"pages":[{"title":"关于 Ray Eldath","text":"Ray Eldath，位于银河系猎户座悬臂末端某星球的一只黑猫猫： 聪慧过猫。会🥁，家里有一套巨扰民的美派斯，经常被投诉，梦想是攒钱买到PAISTE 900 Ride和Byzance HiHat。正在学🎸，练习的时候经常怀疑自己的手指数量。 喜欢外国文学和科幻。初一开始看的SFW，很可惜的是看了这么多年基本都是图书馆借的… 手头有的杂志没有多少，很希望2023年能去成都参加Worldcon…… 对黄金时代科幻和大刘式科幻不大感冒，较喜欢新浪潮科幻；最喜欢的科幻作家是海因莱茵；国内有一些浪漫主义中短篇科幻也很喜欢，比如阿缺的很多作品（如《彼岸花》），《闪耀》还有《七个吻》等。除开科幻最喜欢的作家是阿尔贝·加缪，还比较喜欢黑塞、海明威和毛姆 再也不喜欢了，《刀锋》看了一半实在看不下去了… 现在本猫猫是毛姆黑=_= 。欢迎安利各种作品qwq 稍微看一些动漫，现在基本退宅，喜欢《EVA》和《夏目友人帐》。有一只朋友送的喵咪老师，很开心。 技术菜，在认识的技术圈里几乎垫底… 经常自闭。目前很迷茫，正在瞎学东西，期望未来能做大数据方向的工作 每日自闭+躺平浪费时间。GitHub地址见左侧，欢迎互fo。 喜欢旅游，喜欢大城市的气息。大学四年理想是换电脑+富士XT30+在护照过期前去一趟日本。期望能实现 估计实现不了了…….. 大哭哭 从小到大成绩都差，不喜欢也不擅长数学物理，一生之敌；努力太晚，吃了很多亏。 欢迎在左侧关注本猫的Telegram Channel；如果有想和本帅猫交换友链的欢迎留言。爱你们。 哦对了，如果你是薰党，那我们就是一辈子的好朋友了！ ⁄ ( ⁄ ⁄ • ⁄ ω ⁄ • ⁄ ⁄ ) ⁄","link":"/about/index.html"},{"title":"留言板","text":"留下足迹吧！","link":"/messages/index.html"}],"posts":[{"title":"阿尔贝·加缪其人","text":"他在本世纪顶住了历史潮流，独自继承着源远流长的警世文学。他怀着顽强、严格、纯洁、肃穆、热情的人道主义，向当今时代的种种粗俗丑陋发起胜负未卜的宣战。但是反过来，他以自己始终如一的拒绝，在我们的时代，再次重申反对摒弃道德的马基雅维利主义，反对趋炎附势的现实主义，证实道德的存在。 阿尔贝·加缪是蜚声中外的剧作家、文学家和哲学家。因其以荒谬、彻悟和反抗为核心的“荒谬主义” “热情而冷静地阐明了当代向人类良知提出的种种问题” 而获1957年诺贝尔文学奖，获奖时年仅四十四岁。1913年11月7日，加缪出生在阿尔及利亚小镇蒙多维的一个工人家庭，如他自己所述，“赤贫”、“从来是一个无产者”，贫困构成了加缪早年生活的基调；不仅赤贫，失去父亲更使得加缪“孤立无援”，“只能靠一己之力领悟道理，养成独立的人格，成长为一个男子汉”。在这样的环境下，在向他提供无尽财富，沙滩、阳光和大海的贝尔库贫民区，加缪与伙伴们快乐地玩耍、成长、在温热的海水中游泳，在日光之下嬉戏。加缪对那样的时光满怀感激和怀念，这在《第一人》中体现地淋漓尽致：显然，早年的困苦生活并未阻挡这位作家对世界、人类、大地和痛苦的关切，从《鼠疫》中里厄医生和塔鲁初次见面时的长谈，到作品结尾塔鲁那段发人深省的自白，无不表明正是这种困苦，教会这位未来的诺奖得主要善良，要关怀人，要同情人，要有怜悯之心。1924年6月，加缪以一如既往的优异成绩成为家族中第一位有机会就读中学的人；在他的学生生涯中，这位作家与他的小学教师路易·热尔曼从普通的师生关系到忘年交，加缪从未忘记这位指引了他方向、带给了他光明的德高望重的法语特级教师，他共有四部作品、文章献给这位教师，其中包括诺贝尔文学奖答谢词。1937年5月10日，《反与正》出版，标志着加缪正式进入文学界。在加缪不长的文学生涯中，他发表了多部文学、哲学著作和剧本，还在各大进步报刊上声援抵抗组织，并身体力行地承担情报搜集和出版任务，同皮亚、雷诺等抵抗运动战士联系密切。1943年6月，加缪的戏剧《苍蝇》首演，获得极大成功；在首演式上，加缪认识了著名存在主义哲学家萨特，并与之结下友谊，他们经常在咖啡馆讨论政治、哲学和文学，萨特也多次表达对这位“年轻小伙子”的喜爱——直到1951年。1951年10月18日，《反抗者》出版，加缪在该书中提出的新人道主义引发他和萨特长达一年的激烈论战，并以两人的彻底决裂结束。1959年11月，作品《第一人》第一部分初稿完成，他计划在1960年7月完成初稿，并于1961年完成第二稿，或许即是定稿。 但这一切在次年年初戛然而止——1960年1月4日，阿尔贝·加缪乘汽车回巴黎时车祸身亡，享年四十六岁。他的离世给法国知识界带来极大震动，一时间悼念文章铺天盖地。在这些悼念文字中，尤以加缪的前论敌——或许还能称为“前”“前挚友”——萨特的悼词最为感人，也即是本文开头引用的那段话。随着加缪的离去，他所关注的政治问题也走向彻底解决，其哲学讨论亦被人们遗忘，加缪的思想和声音，便逐渐成为已然逝去的历史中一种遥远而模糊的回响。 进入二十一世纪，新的问题和挑战接踵而至。恐怖主义抬头、难民问题、气候变暖，现在还有全球性病毒的空前大流行和根深蒂固的种族歧视：种种危机使迷茫困惑的人们又将目光重新聚焦到这位英年早逝的哲学家上来。半个世纪过去，如今加缪朝思暮想的阿尔及利亚已经独立，二十世纪欧洲知识分子的左倾狂潮也早已过去，那些冷静下来、又一次认识到这位文笔凝炼的作家的文字中蕴含有深刻、富有道德意义和一种伟大的人道主义的哲理的人们，大概不会否认阿尔贝·加缪半个世纪前领悟到的道理，仍闪耀着沉重但轻盈、伟大但平凡的人道主义光辉： 在这儿我领悟了人们所说的光荣：就是无拘无束地爱的权力。 ——阿尔贝·加缪 纪念碑文阿尔及利亚 — 完。— 参考： 《加缪全集》阿尔贝·加缪 《加缪生平与创作年表》李玉民 《论加缪的思想与创作》柳鸣九 《加缪的自我解码》李玉民 以前写的蠢东西… 拿来凑个数好了qvq","link":"/literature/albert-camus/"},{"title":"First Step Towards FPGA (1): SystemVerilog Quick Take &amp; Pros and Cons","text":"Every time programmable hardware programming is mentioned, Verilog or SystemVerilog comes to our mind — such fact, IMHO, is ironically contrasts with another interesting, if not consensus, but at least first impression of those hardware newbies just like me, that the fundamental software and development toolkit in hardware programming field is far from diverse, mature and easy-to-use. Comparing to software engineering, there are not too much languages, tools or methodology to let you pick and choose, even among the limited available choices, most of them are either lack some important features, or just too expensive to investigate. Undoubtedly my first step towards FPGA, looking around and pick a combination of language, simulator and testing method, is a brief journey, but it also involved too many investigation as well as unexpected disappointment, which makes this journey more difficult, and more tiring. This article is intended to outline some of my conclusion, which is what I’m using now, and what I have used but quited. For me, there is a long-lasting haunting thought — writing a CPU, and that is the beginning of the story. About half a month ago I set sailed, and till now I have finished a testing library for Verilator, and a very simple MIPSs CPU that have nothing to do with pipeline, trap, and whatnot. So conclusion comes first: I’ve done most of these in combination of SystemVerilog (language) + Verilator (simulator) + CLion (IDE) + althas (testing) + Xilinx Vivado (synthesis). I will explain the reason just below. I’ll not gonna say this is the best workflow of hardware programming, specifically FPGA programming, it still have many incompetence in terms of my requirements which I’ll talk about them later as well, but I do hope this article could help you find a workflow that just suits yourself. This article will only discuss the very first part of my workflow, namely the SystemVerilog part. Remaining techniques will be discussed in the follow-on articles of this series, so stay tuned! Verilog / SystemVerilog ?JUST DON’T ask why VHDL is not mentioned. I won’t discuss VHDL here, for one thing I know nothing about this language, and for another I think it’s somewhat considered obsolete or just not recommended in many existing articles like this one. What’s different?SystemVerilog has been described as a superset of Verilog, which is another predominant language in hardware programming field, and it certainly is. SystemVerilog have an impressive outstanding compatibility with Verilog, most synthesis environment, at least Xilinx Vivado, allows you to instantiate Verilog module in SystemVerilog module and vice versa. Many Verilog definition could be directly translated into SystemVerilog, without or with only little altered. Here is a piece of code taken from my CPU project astrio (currently it’s still in private, I’ll publish it once I finished pipelining, trap, AXI bus and implementation on Zynq SoC, all sort of things), it can help you — I assume you already knew Verilog, and understand what these assign, always means — glimpse at the vanilla-SystemVerilog, and understand what’s new there: >folded pc.svsee code on GitHub1234567891011121314151617181920212223242526272829303132333435363738import Parameters::*;import PCType::pc_cmd_t;import Types::addr_t;module PC( input PCType::pc_cmd_t cmd, input addr_t load_pc, input bit rst, input bit clk, output addr_t pc, output addr_t inc_pc); initial pc = InstStartFrom; addr_t next_pc; assign inc_pc = pc+4; always_comb begin unique case (cmd) PCType::NONE: next_pc = pc; PCType::INC: next_pc = inc_pc; PCType::INC_OFFSET: next_pc = inc_pc+load_pc; PCType::LOAD: next_pc = load_pc; default: next_pc = pc; endcase if (rst == 1) next_pc = InstStartFrom; end always_ff @(posedge clk) pc &lt;= next_pc;endmodule : PC It’s not difficult to find out that there are many differences comparing to Verilog. I’ll highlight those are most important or influential in terms of the actual programming work: typedef in SystemVerilogYou may notice that there are some addr_t stuff in the code, and even if you are just a newcomer of C, you may still notice that here we adhere to the general naming convention of a typedef, namely suffixed whatever a typedef with _t, which I think is just inherited from C’s naming conventions. So as you may assumed, SystemVerilog do have typedef. Let’s look at the definition of addr_t: types.svsee code on GitHub12345678910package Types; typedef logic unsigned [31:0] addr_t; typedef logic signed [31:0] op_t; typedef reg signed [31:0] op_reg_t; typedef logic unsigned [4:0] reg_id_t; typedef logic unsigned [31:0] inst_t; typedef reg unsigned [31:0] inst_reg_t;endpackage : Types Okay, now it’s pretty clear. Generally typedef in SystemVerilog is no different from its counterpart in C/C++. Intuition always right, just use typedef (type) (name) to define your own data type in SystemVerilog to make your code more concise and configurable. BTW, typedef is a great replacement for parameter in many cases, use it wisely, and your code will definitely looks better. But, wait, what the hell is the package? package &amp; import: Package system and separate compilationExtract the common definition of your code, wrapped them in a package or whatever is always a good idea. It improves the readability of your code, alleviate namespace conflicts, and enables the separate compilation, i.e. when the code are recompiled, only the modified part is needed to be recompiled while the common and relatively less frequently modified part can be excluded, so less files will be recompiled, therefore speed up the recompilation. SystemVerilog supports such encapsulation by providing keyword package and import: the former is for encapsulate, the latter is for import it. One thing should be noticed: if you read my codebase that linked hereinbefore, you may find that only typedef, functions and some parameters are encapsulated in package, this is because typically they are the common part of your code. I won’t encapsulate my module in package, seems to me it just don’t deserve. enum &amp; enhanced case clause: enumeration works like a charmIn the pc.sv code above, there is a input cmd typed PCType::pc_cmd_t. You may guess that this is a typedef defined in package PCType, but what the actual type is? Continual reading, the input cmd is passed into a unique case clause, perhaps it’s something akin to enumeration? And unique means that there are no overlapping between the matching conditions, so only one block will be triggered in any cases? You are right! Here’s the definition of pc_cmd_t: pc_type.svsee code on GitHub12345package PCType; typedef enum bit [1:0]{ NONE, INC, INC_OFFSET, LOAD } pc_cmd_t /* verilator public */;endpackage : PCType Here we define a enum that occupies a 2 bit wide bit, then aliased it as a pc_cmd_t, where we adhere to the appreciated naming conventions. The whole definition is encapsulated in a package named PCType as I discussed before. Still there are something weird — what is the bit? And why there is a comment /* verilator public */? I am going to talk about the bit thing right now, but for the Verilator thing, till we know what Verilator is and what can it do can we grasp at the idea, so the answer is in the follow-on articles of this series. logic &amp; bit: abundant but systematic built-in datatypeIn addition to the native datatypes directly inherited from Verilog, lots of new datatypes are described and added. Presumably the most crucial subset of these novel datatypes (I think many of them is just excessive abstraction and design and actually not so required but make the language considerably more complex. I’ll back to this point later) is logic and bit. Technically you can regard logic as wire plus reg. Datatype logic wipe out the delimited wire and reg, for synthesizer will deduce the underlying hardware (a wire or a register) automatically, using the context. But if you are declaring a tristate gate like inout, you have to use wire but not logic. Why is that? The reason is logic-typed variables can only have one driver. No surprise here, logic still have four state: 0 (low), 1 (high), X (unknown) and Z (tristate gate high-impedance), but in many cases we can firmly believe that only two state, 0 and 1, will be involved. And that’s what bit used for. It’s a apt datatype for defining enumeration. Actually there are plentiful datatypes newly added into SystemVerilog, and most of them are not mentioned here due to some reasons, and I’ll come to this later. always_XXX: enhanced always clause enable fine-grained elaboration hintMaybe the most complex, sophisticated and perplexing part of Verilog/SystemVerilog is the always clause. Without intensive study, profound understanding and very careful development, unintended latch or flipflop will be deduced with no warnings, which surely is a bad thing. SystemVerilog partially solve this problem by giving you fine-grained elaboration hint. There are three types of new enhanced always clause: always_comb: Next time you write down always @(*), try always_comb! This type of always clause family will automatically listen to all left-side wires and registers in your begin … end block, thus sensitive signal list should not be specified. Simulator and synthesizer will ensure that only combinational logic is deduced, and if not, a warning (or error?) will be thrown. You should not use delayed assignment (&lt;=) in the context as well. always_ff @(...), always_latch @(...): Take their names literally, these two clause is for sequential logic. One will hints simulator and synthesizer to deduce flip-flop, the other will deduces latch. The sensitive signal list is required, and you should specify the sensitive signals in it, exp. always_ff @(posedge clk), just like in Verilog. Silver Bullet?But still, SystemVerilog is not the silver bullet, and here are some downsides. Relatively poor ecosystemBefore you switch to SystemVerilog (which I highly recommend, as many renowned hardware workshops and companies had done so), the very first as well as the most significant thing you should deliberately consider is ecosystem. That is to say, does the synthesizer, implementation program or IDE support SystemVerilog? And if not, apparently SystemVerilog can not be a practical option. The good news is that almost every conceivable mainstream FPGA manufacture provides development environment with bundled SystemVerilog support — but the bad news is SystemVerilog is only supported in their relatively newer version of software. Take Intel and Xilinx as example, only Quartus II 11.1 and above and Vivado v2017.3 and above support SystemVerilog. So if you’re planning to program on old devices, such as a Xilinx Spartan-6, you are not able to use SystemVerilog since Vivado only supports 7 generation FPGA products (Zynq 7000 SoC, Artix-7, Kintex-7 and Virtex-7). Notice that some so-called individual manufacture, in particular Alchitry — the manufacture of the somewhat relatively reputable cheap, newcomer-friendly FPGA development board Mojo, do not provide SystemVerilog in their dedicated IDE as well. SystemVerilog is (overly?) complexAs I mentioned before, SystemVerilog is a complex HDL. But the problem is it’s not just simply complex, it’s somewhat overly and unnecessarily complex. Comparing with Verilog, actually many enhancements are reasonable, adequate and competent, but the other side is there are many features just trying to make coding in SystemVerilog as closer to coding in some high-level language, let’s say C++ and Java, as possible, and this way is just not so great. Many language features and keywords, such as datatypes int, longint, real, crappy multi-thread support, keyword automatic for recursive functions, they are not used in my day-to-day programming, but makes SystemVerilog unreasonably complex — as a HDL, whose theoretical role is just describes wires between hardware structures. I’ll say that this attempt, trying to “disguise” SystemVerilog as a high-level language will indeed improve the testing experience. (Personally speaking the TESTBENCH-based and $display-based testing methodology of Verilog is incredibly inefficient and grueling, I suppose the SystemVerilog way of doing things will be a lot easier) But, I still hold the belief that HDL should be a HDL solely, and high-level language should be a high-level language solely. It’s just redundant, and usually a bad idea to let one side covers the other side, or to “be” the other side. Given the consensus that hardware validation and testing, especially the generation of testcases should be performed in a high-level language, maybe use a high-level language to do such things will be a great idea — and Verilator is created for this. I will cover Verilator and related topics in the next article. After all, this is just a personal preference and personal perspective, and language is just a tool. If it’s too complicated, just pick out the acceptable part: and this is exactly what I’m doing. Use what I called vanilla-SystemVerilog is just stick to the principle that SystemVerilog is nothing but a HDL language, you should only use the HDL part of it, take is as a “better Verilog”, use entirely a handful of features and enhancements including what I mentioned before. Limited featuresEven if your environment fully support SystemVerilog in elaboration, synthesis and implementation, your switch may still not very pleasant as you may expected. Specifically, my Vivado v2019.2 satisfactorily supports SystemVerilog in normal develop procedure, but you can’t add your SystemVerilog modules to your Block Design directly. Overall this is not a big problem, in my case all I need is just to create a wrapper in Verilog then linked IPs to that wrapper, but your mileage may vary. It all depends.Eventually comes the golden rule of selecting things in the realm of techniques, technicians, languages and programmers — “It all depends.” As I said, language is nothing but a tool, how to use it and to what extent will you use it in the daily basis, is just personal predilections. Tons of tutorials and blog posts will teach you how to use SystemVerilog as a high-level language and do validation things in such way elegantly — and I bet many people are good at it. But I’m just not on their side, nor am I appreciate their methodology. Hope this article will help you get the basic difference, pros and cons of SystemVerilog, comparing with Verilog, and then decide whether to put it in your own workflow. The next passage will cover another facet of my workflow — Verilator, it lets you simulate and validate your DUT in C++/System C, which is a lot better then do such things in HDL, personally speaking.","link":"/hardware/fpga-journey-1/"},{"title":"我的大一啊，sigh","text":"那啥，本来是不大喜欢写什么“总结”之类的东西的，一来这些东西本来用处不大，写着也浪费时间；二来按什么“有多少个‘第一次’”诸如此类的分类式总结，咱记性又不怎么好，让我硬去凑这些个分类，也不怎么好玩。 可是啊，最近实在是有点太迷茫了，感觉不回望下过去，未来也不知道应该做什么；有些太累了啊，对计算机和代码、和种种本应坚持的事情的兴趣如果不是已经消退——希望不是——也是锐减了，或许这就是颓废吧。 所以，各位应该已经从字里行间闻出来了——这是一篇自我色彩浓重的文章，尤其是，不可避免地包含了大量自己对自己的评价和看法。当然这一年来也少不了技术，但若读者期望要从本文中获得什么知识性的见解之类，恐怕是要落空的了。 这就算是safe harbor了——若对这样色彩的文章不屑一顾的读者，想必对我这样的人，也不会有什么兴趣的；若是如此，本文自然不是为您而写的啦——毕竟这是个人博客，自我色彩浓重的文章，也没什么不应该的吧？ &nbsp;头图摄于2019年国庆期间，于广州地铁三号线地狱西。 技术前两天在群里搜一个大佬发的链接的时候偶然翻到了去年二月份在群里的发言，发现自己那个时候在群里问了一个有关Kotlin声明处变异和类型上界的问题…… 问题是挺基础的，我想我现在应该不会再问这样的东西了。不过，想到有很长一段时间都受身边人的影响强行把时间和精力都砸到了并不喜欢、并不感兴趣的方向上，感觉确实是蛮不应该的——细想了想自己学很多东西的时候很难分辨出「感兴趣，喜欢！」和「哇这个好酷好帅好高大上教练我也想学」之间的区别，很多时候做的一些事情、学的一些东西与其说是真正学到了什么，“提升”了自己什么，不如说仅仅是为了让自己在「别人的眼中」很厉害而已——但事实上却完全不是。 一年以来，我已看到真正低调的强者是什么样子。和真正的大佬比起来，我想我确实是只会被秒得体无完肤而已：面对一群拥有你极度渴望的器物和能力，达成了你始终认为高不可攀的成就，经历你自认只能永远观望的体验——这样的感受并不奇怪，我会为此开脱，这样的想法，是平凡的： 但是，这个回答却也是再正确不过了——何必呢？ 何必呢？可或许这样的一课是避不开的吧。很早以前「友人P」（这么匿名式的称呼感觉好好玩啊 (￣▽￣)”）在评论一位我们都认识的网友时说（大概是这样），他正在经历认识到自己并不天才并不全能的阶段——我大概也会这么说现在的自己吧。这样的挣扎，对于一些本就十分低调、十分「擅长反思」并对自恋心理和自我中心主义怀有警惕的人们来说想必看起来是既可笑又幼稚，但只可惜我不是那样的人：我是挺幼稚，也挺可笑的。 果然如预想中那样跑偏了——一年来我学到了什么呢？除了这样的仍「在路上」的认识，我想，或者说，我希望，自己技术上还是有所进步的——至少我，至少应该不会再问“Kotlin中什么和Java的 extends ? 对应？”这样的问题了…… 吧。 Kotlin熟练II，开了个DSL的新坑；后端踩坑无数，Exposed，Ktorm；Ktor，http4k。还有gRPC，那会儿官方的Kotlin支持还没出，社区做的kroto+是真的难用…… 不过现在的官方支持倒是没用过也没看过。 计组专精II，整了整计组，看完了《软硬接口》，正在拿SystemVerilog和Verilator写简单的MIPS CPU，到本文写作时基本完成了18条核心指令的支持、五级流水线和所有的冒险检测、旁路之类，打算再把cp0也给弄弄…（可以康康咱以前写的博客文章，希望还会继续更新……） 老实说并不如之前想的一样那么难。以前总觉得「哇，这个东西那么牛逼，我这辈子肯定都搞不定」就连真正坐下来写的时候也总想「唉，要写流水线了，这难得要死肯定不会弄」、「唉，要做旁路了，这太复杂了肯定整不出来」之类，但是写完了就有种「就这？」的感觉… 如果瞎想是一项运动，我早TM是世界冠军了。 函数式有点兴趣。看了一些乱七八糟的文章和conf，还发现了一本挺棒的Haskell书书，一千多页看了两百多了… 英文不好看的很慢，可惜也没办法；打算继续看完，期望是人生第一本读完的英文书籍… Scala专精I。总算是看完了喵呜呜很早很早很早以前送的Scala书书，被圈粉。写了一些没什么用的试验代码和一点gRPC的测试，不得不说ScalaPB比kroto+好用多了… 还看了看Dotty的强强语法，是真的强强。 过度设计专精II。写项目架了一个超大超傻的技术栈，容器化docker-compose，反代traefik，web托管Caddy，后端AdoptOpenJDK，OAuth认证中间件Hydra，业务数据库MySQL，时序数据库Graphite，可视化Grafana，容器管理Portainer，资源监测Netdata…… 感觉自己简直脑抽，希望还是学到了什么东西吧…… 总的来说就这些。还看了看Vim之类，不过用的很少，也不怎么熟… IDEA倒是用得熟练多了，新记了不少快捷键；现在对敲键盘时还要不时碰一碰鼠标这样的打扰要敏感多了。 按我这个后见之明偏误由来已久的功利主义上脑的废物的习惯，自然要问的问题就是——这些时间中，有多少花得值呢？写不写一个五级流水线CPU、知不知道什么是TLB、能不能用MIPS写递归求阶乘、了不了解操作系统如何管理内存——这些到底在多大程度上会影响未来的——尽管，我无比希望能是「现在的」——实习和工作？一个所谓科班出身，学习过这方面内容的程序员，和一个对此毫无了解的程序员，在应对千变万化、纷繁复杂的实际业务需求时，到底会有怎样的差别？ 我不知道。程序员社区里总有人讨论这些，也总有人说，这些会渗透进思维中，或者足够高要求的业务总会逼迫用上这些东西云云。但是真的如此吗？ 现在做的东西到底有意义吗？我走的路是正确的吗？ 我未来到底要做什么？我到底喜欢什么？我到底喜欢计算机、喜欢技术吗？ 唉，我也不知道。很喜欢写Web后端吗？很喜欢Vue.js糊前端吗？很喜欢做存储、基础设施吗？很喜欢大数据吗？很喜欢FPGA吗？很喜欢化学实验吗？很喜欢计算机吗？？ 如果不是，如果对任何已知的方向说到底都没有多少兴趣，那该怎么办？ 去年，或者即便是今年早些时候，我都还有想着几项不多、但对我来说相当昂贵的梦想，想着大学有闲的时候能有钱自然是再好不过；现在看来，大概只是空想而已吧…… sigh. 生活最轻松、最好讲的部分当然要放在最后面啦——不过，看到这儿还不觉得是在浪费时间的读者，应该也没有几位了吧？ 高中毕业之后的假期和网友面包包、🍋、信酱酱去上海组队打了一次hackathon（需要理解，那时候我还以为自己天下第一…），之后和前两位在上海玩了两天。 人生第一次自己在外边旅游，真的挺舒服的。很自由。（当然得有钱… 如果这钱是自己挣的就能是百分百的无忧无虑了，可惜于我而言这估计还是令人难受地遥远…） 后来国庆的时候和（几乎是唯一几位比较熟的）朋友们去了广州，也即本文头图的由来。总感觉一个城市有没有河、靠不靠海是很大的区别，希望以后自己也能在一座有河或者靠海的城市工作、生活。 今年一月份一个人去了趟深圳。老实说一个人自由多了，到处跑，两天去了好多地方。面基了腾讯大佬t桑，羡慕了一圈老干妈总部内部实用简单的精致；只可惜那时候还不认识e哥，第二天去深圳湾天气也不大好。 去的绝大部分美术馆、博物馆都是免费的，不仅免费还送纪念品，有钱的城市就是任性。市民中心底下就是深圳市政府，一整片玻璃幕墙，身体力行地告诉你什么是有钱的现代化城市。市民中心那片的公建是真的有艺术感，太富了。当时想着要在深圳工作生活，现在想想还是算了…… 旅游就是拍拍拍，自那以后就很想拥有一台富士XT-30，或者什么相机之类，不知何时才能摸到自己的截幅微单呢。 日光之下没了，这篇文章就到这。希望下一篇能回归有些用的技术主题文章吧。 不过最希望的还是，时间能为我解答这些让我完全睡不着觉、每天要翻腾两三个小时，代码也没法写、只能每天躺平浪费时间的恼人问题啊…… 不过最最希望的还是，能当下送我一个大厂的实习就好了啊。（大哭哭） 十点了，又浪费了一天。","link":"/life/freshman/"},{"title":"咱的新博客","text":"一直打算自己写博客的一套前端和后端，前端本来已经写了挺多的了，现在看来是要搁置很长一段时间了… 感觉折腾这些毕竟没啥用，还是要花时间写文章才行。。 可文章也太难写啦QAQ，每次都感觉开坑写了两行就不想动了，总感觉有些东西不能说得有些见地就不如干脆不动笔以避免「灌水」之嫌。总之以前的文章大概是不会发上来了（因为太黑历史了，哭哭）这个博客大概会放些近期自己写的东西，科幻评论啊，以及稍微长一些、图文并茂的、不适合放在咱Telegram Channel（左侧有链接）的一些玩意，向e哥和冰冰两位大佬看齐QAQ 就是这样。总感觉现在这个新主题有点太冷淡了些，以后再慢慢调吧……","link":"/misc/hello-world/"}],"tags":[{"name":"阿尔贝·加缪","slug":"阿尔贝·加缪","link":"/tags/%E9%98%BF%E5%B0%94%E8%B4%9D%C2%B7%E5%8A%A0%E7%BC%AA/"},{"name":"文学","slug":"文学","link":"/tags/%E6%96%87%E5%AD%A6/"},{"name":"硬件编程","slug":"硬件编程","link":"/tags/%E7%A1%AC%E4%BB%B6%E7%BC%96%E7%A8%8B/"},{"name":"SystemVerilog","slug":"SystemVerilog","link":"/tags/SystemVerilog/"},{"name":"FPGA","slug":"FPGA","link":"/tags/FPGA/"},{"name":"矫情","slug":"矫情","link":"/tags/%E7%9F%AB%E6%83%85/"},{"name":"没什么用的回忆","slug":"没什么用的回忆","link":"/tags/%E6%B2%A1%E4%BB%80%E4%B9%88%E7%94%A8%E7%9A%84%E5%9B%9E%E5%BF%86/"}],"categories":[{"name":"literature","slug":"literature","link":"/categories/literature/"},{"name":"hardware","slug":"hardware","link":"/categories/hardware/"},{"name":"life","slug":"life","link":"/categories/life/"},{"name":"misc","slug":"misc","link":"/categories/misc/"}]}